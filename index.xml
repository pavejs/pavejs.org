<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PaveJS</title><link>https://pavejs.org/</link><description>Recent content on PaveJS</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://pavejs.org/index.xml" rel="self" type="application/rss+xml"/><item><title>404 - File not found</title><link>https://pavejs.org/404.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pavejs.org/404.html</guid><description>404 File not found</description></item><item><title>Aliases</title><link>https://pavejs.org/docs/queries/aliases/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pavejs.org/docs/queries/aliases/</guid><description>Aliasing Fields Because of the POJO nature of Pave, the only requirements to alias fields is simply another key on a query object. When provided, Pave will take that as the name of the queried type, as demonstrated below.
// Query user, but with an alias query: { myModelNameHere: { _field: &amp;#39;user&amp;#39; _args: { id: 123 } id: {}, name: {} } }
Application This is particularly useful in cases where you need to query the same field twice in the same request, at the same level.</description></item><item><title>Arguments</title><link>https://pavejs.org/docs/queries/arguments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pavejs.org/docs/queries/arguments/</guid><description>Basic Arguments Every querying language would be a hollow shell if not for the ability to provide arguments to the query. These properties are what can be read and resolved on the server side of your queried function.
Example // Query createUser, with arguments query: { createUser: { _args: { name: &amp;#39;John Doe&amp;#39;, address: &amp;#39;1600 Pennsylvania Ave.&amp;#39;, emailAddress: &amp;#39;jdoe@example.com&amp;#39; } } }
Advanced Arguments While the example above is incredible rudimentary, there is massive potential to implement several advanced features off of the back of arguments.</description></item><item><title>Arguments</title><link>https://pavejs.org/docs/schemas-and-types/arguments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pavejs.org/docs/schemas-and-types/arguments/</guid><description>Header Content</description></item><item><title>Enumerable Types</title><link>https://pavejs.org/docs/schemas-and-types/enumerable-types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pavejs.org/docs/schemas-and-types/enumerable-types/</guid><description>Header Content</description></item><item><title>Extra Packages</title><link>https://pavejs.org/docs/extra-packages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pavejs.org/docs/extra-packages/</guid><description>List of Packages pave-basic-types &amp;mdash; A set of basic types for your schema pave-basic-types The pave-basic-types package provides a out-of-the-box set of scalar types for jumpstarting your schema construction. Instead of writing boilerplate types such as string, int, or otherwise, just import this package via your package.json and extract either all of it or just what you need.
Examples All import basicTypes from &amp;#39;pave-basic-types&amp;#39;; export default { ...basicTypes, .</description></item><item><title>Fields</title><link>https://pavejs.org/docs/queries/fields/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pavejs.org/docs/queries/fields/</guid><description>Simple Fields As with every querying language, one of the largest benefits is the ability to pick and choose what data you pull from your server, removing worries of having a bunch of data being pulled from the database without need. In Pave, defining what you would like back follows the same theme of all other aspects of Pave; it&amp;rsquo;s simple.
For instance, let&amp;rsquo;s assume we have a model of type User with available fields name, phoneNumber, emailAddress, and address defined on that type.</description></item><item><title>Functions</title><link>https://pavejs.org/docs/schemas-and-types/functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pavejs.org/docs/schemas-and-types/functions/</guid><description>Structure All functions have a set of fields which are required by Pave in order to provide arguments, validate return, and resolve the function itself. These fields are as follows:
Arguments (args) A dictionary of key-value pairs following field:type structure
These arguments will reappear in your resolve fn, a separate field on the function, in the format you described. In this manner, you can also define args as optional or nullable, with an important distinction between the two.</description></item><item><title>Introduction</title><link>https://pavejs.org/docs/getting-started/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pavejs.org/docs/getting-started/introduction/</guid><description>The Basics Before any queries can be written, or schemas implemented, it is important to first get an understanding for Pave and it&amp;rsquo;s underlying mechanisms, in order to be able to implement a system around it which works in synergy to take full advantage of Pave&amp;rsquo;s features.
Summary Pave is an open-ended querying language written in Javascript (with translations for select alternate languages) that intends to provide a common-ground language of communication between front-end and back-end code.</description></item><item><title>Model Types and Fields</title><link>https://pavejs.org/docs/schemas-and-types/model-types-and-fields/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pavejs.org/docs/schemas-and-types/model-types-and-fields/</guid><description>Basic Models Beyond your basic scalar and other types, your schema will need to have a notion of the different types of models you have available, and their respective fields, in order to have context when processing your query. This is why, as we&amp;rsquo;ll get into in further sections, all functions must describe what type of model they return.
Because of this, your unique models must be defined in your schema as well, if you intend on referencing them or returning them in any manner through Pave.</description></item><item><title>Quick Start</title><link>https://pavejs.org/docs/getting-started/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pavejs.org/docs/getting-started/quick-start/</guid><description>5 Minute Setup This guide will walk you through getting Pave setup and working in your project
Installation Getting pave setup and running your environment is easy and painless. Naturally, the first step of setup is to install Pave by declaring it in your package.json file in your project, as shown below.
// In your projects package.json { ... &amp;#34;dependencies&amp;#34;: { &amp;#34;pave&amp;#34;: &amp;#34;0.10&amp;#34;, } } Once this is included in your dependencies, and npm install is ran, Pave will now be included in your project.</description></item><item><title>Scalar Types</title><link>https://pavejs.org/docs/schemas-and-types/scalar-types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pavejs.org/docs/schemas-and-types/scalar-types/</guid><description>Structure All returned fields under models and even other types must be made up of basic scalar types. Scalar types are only required to possess a single field, resolve, which is applied to values assigned to that type to format, validate, or otherwise transform it to fit a normalized type.</description></item><item><title>Structure</title><link>https://pavejs.org/docs/schemas-and-types/structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pavejs.org/docs/schemas-and-types/structure/</guid><description>A System of Models It&amp;rsquo;s been quite obvious thus far that Pave, in accordance with the standard set by many other querying languages, is strongly based on the idea of intrinsic model types, and the notion that said models have fields.
Schema Location All externally interactive types (i.e., types which are expected to be queried and results returned) on the API are stored in a special schema type named root. This schema type will export all fields that will be externally interactive.</description></item><item><title>Variables</title><link>https://pavejs.org/docs/queries/variables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pavejs.org/docs/queries/variables/</guid><description>Dynamic Variables More often than not, when working with queries, you&amp;rsquo;ll often want to pass variables into your query. One of the largest upsides of Pave, that has been mentioned previously, is the fact that every query is in the form of a Plain Ol' Javascript Object.
The implication this has, in the context of dynamically inserting variables into queries, is that it&amp;rsquo;s as simple as assigning an argument object key to a previously defined variable.</description></item></channel></rss>